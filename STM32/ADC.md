# ADC

## 一、ADC简介

### 1.1 简述

* ADC 即模拟数字转换器，英文详称 Analog-to-digital converter，可以将外部的**模拟信号**转换为**数字信号**。
* STM32F103 系列芯片（除C8T6 只有 2 个ADC外）拥有 3 个 ADC，这些 ADC 可以独立使用，其中 ADC1 和 ADC2 还可以组成双重模式（提高采样率）。
* STM32 的 ADC 是 12 位逐次逼近型的模拟数字转换器。
  * 它有 18 个通道，可测量 16 个外部和 2 个内部信号源，其中 ADC3 根据 CPU 引脚的不同其通道数也不同，一般有 8 个外部通道。
* ADC 中的各个通道的 A/D 转换可以**单次**、连续、**扫描**或**间断**模式执行。
* ADC 的结果可以以**左对齐**或者**右对齐**存储在 16 位数据寄存器中。 

### 1.2 STM32F103 的 ADC 主要特性

  1.  12 位分辨率； 
  2.  转换结束、注入转换结束和发生模拟看门狗事件时产生中断
  3.  单次和连续转换模式
  4.  自校准
  5.  带内嵌数据一致性的数据对齐
  6.  采样间隔可以按通道分别编程
  7.  规则转换和注入转换均有外部触发选项
  8.  间断模式
  9.  双重模式（带 2 个或以上 ADC 的器件）
  10.  ADC 转换时间：时钟为 72MHz 为 1.17us
  11.  ADC 供电要求：2.4V 到 3.6V
  12.  ADC 输入范围：$V_{REF–}$ ≤ $V_{IN}$ ≤ $V_{REF+}$
  13.  规则通道转换期间有 DMA 请求产生

## 二、ADC配置详解

### 2.1 ADC 输入范围

* ADC 输入范围：$V_{REF–}$ ≤ $V_{IN}$ ≤$V_{REF+}$

* 最终还是由$V_{REF–}$ 、$V_{REF+}$ 、$V_{DDA}$和$V_{SSA}$决定
* ![image-20231102195139580](https://raw.githubusercontent.com/undefined-0/image-store/main/PicGo/202311022224909.png)
* 如图，$V_{DDA}$和$V_{REF+}$接 VCC3.3，$V_{SSA}$和$V_{REF–}$接地
* 所以ADC的输入范围为 0~3.3V

### 2.2 ADC输入通道

* 我们使用ADC 的输入通道把外部输入的电压输送到 ADC 转换器中。
* ADC1：16 个外部通道和 2 个内部通道
  * ADC1 的通道 16连接到芯片内部的温度传感器， 是内部通道。
  * ADC1 的通道 17 连接到 Vrefint。
* ADC2：16 个外部通道和 2 个内部通道
  *  ADC2 的通道 16 和 17 连接到内部的 VSS。
* ADC3：8 个外部通道
  * ADC3 的通道 9、14、15、16 和 17 连接到内部的 VSS。
* 完整的**ADC通道表**如下：![image-20231102195940348](https://raw.githubusercontent.com/undefined-0/image-store/main/PicGo/202311022224911.png)

### 2.3 转换顺序

* ADC 的多个通道以任意顺序进行转换 ---> 成组转换。
* 成组转换的两种类型： **规则通道（规则组）**和**注入通道（注入组）**。
* **规则组**允许最多 16 个输入通道进行转换，**注入组**允许最多 4 个输入通道进行转换。
* 以下是规则组和输入组执行示意图。![image-20231102200358082](https://raw.githubusercontent.com/undefined-0/image-store/main/PicGo/202311022224912.png)
* **规则组（规则通道）：**按照一定的顺序，相当于正常运行的程序。使用较多。
* **注入组（注入通道）：**可以打断规则组的转换，相当于中断。
  * 如：在规则组转换过程中，若注入组启动，那么注入组被转换完成之后，规则组才得以继续转换。

### 2.4 规则序列

* 规则组最多允许 16 个输入通道进行转换，那么就需要设置**通道转换的顺序**，即**规则序列**。 

* 规则序列寄存器有 3 个，分别为 SQR3、SQR2 和 SQR1。
  * SQR3 共6个寄存器位，控制规则序列中第 1 个到第 6 个转换；
  * SQR2 共6个寄存器位，控制规则序列中第 7 个到第 12 个转换；
  * SQR1 共5个寄存器位，其中前四位（ SQ13[3:0] 位 ~ SQ16[3:0] 位 ）控制规则序列中第 13 个到第 16 个转换，还有一位（ SQL[3:0] 位 ）用于设置规则序列的输入通道个数。

* 完整的**规则序列寄存器控制关系汇总表**如下：![image-20231102201205009](https://raw.githubusercontent.com/undefined-0/image-store/main/PicGo/202311022224913.png)

* 解释：
  * **设置通道转换的顺序：**想让输入通道 5 在第一个转换，将 5 这个数值写入 SQ1[4:0] 位即可。若还想让输入通道 8 在第 2 个转换，将 8 这个数值写入 SQ2[4:0] 位即可。

  * **设置规则序列的输入通道个数：**将（输入通道个数-1）写入 SQR1 的 SQL[3:0] 位即可。

    * 注：写入 0 到 SQL[3:0] 位时，表示当前规则序列有 1 个输入通道，而不是 0 个输入通道。

      ````text
      0000：1个转换
      0001：2个转换
      ……
      1111：16个转换
      ````

### 2.5 注入序列

* 上面已经详细说明过，**规则序列**决定**规则组**中**通道转换的顺序**。类似地，**注入序列**决定**注入组**中**通道转换的顺序**。

* 注入组的注入序列由 JSQR 寄存器配置，总控制关系表如下：![image-20231102202924368](https://raw.githubusercontent.com/undefined-0/image-store/main/PicGo/202311022224914.png)

* 解释：

  * ##### **设置规则序列的输入通道个数：**
    
    * 将（输入通道个数-1）写入 JL [ 1 : 0 ] 位即可。
    * 注：写入 0 到 JL [ 1 : 0 ] 位时，表示当前注入序列有 1 个输入通道，而不是 0 个输入通道。`（问题：是以此类推的吗？写入15时表示当前规则序列有16个输入通道吗？）`
    
  * ##### **设置通道转换的顺序：**

    * ==⚠️**请注意**⚠️== 注入序列的转换顺序设置==**不同于规则序列**==，具体如下：

    * 如果 JL[ 1 : 0 ] 位的值小于 3（即：设置注入序列要转换的通道个数小于 4），则注入序列的转换顺序从 JSQx[ 4 : 0 ] （其中x=4-JL[1:0] ）开始。

    * 例：

      当 JL [ 1 : 0 ] =10（注：$10_2=2_{10}$，要转换的通道数为2，2小于4）、

      ​	JSQ4 [ 4 : 0 ] = 00100（注：$00100_2=4_{10}$）、

      ​	JSQ3  [ 4 : 0 ] = 00011（注：$00011_2=3_{10}$）、

      ​	JSQ2 [ 4 : 0 ] = 00111（注：$00111_2=7_{10}$）、

      ​	JSQ1 [ 4 : 0 ] = 00010（注：$00010_2=2_{10}$）时，

      意味着这个注入序列的转换顺序是：

      ​	7、3、4，（顺序：JSQ2-->JSQ3-->JSQ4）

      而不是：

      ​	2、7、3。（顺序：JSQ1-->JSQ2-->JSQ3）
  
      正如[前面](#**设置通道转换的顺序：**)所说，JL [ 1 : 0 ] 位的值为2时，注入序列的转换顺序从`JSQ(4-JL[1:0])[4:0]` 即`JSQ(4-2)[4:0]` 即 `JSQ2[4:0]` 开始。同样地，如果 JL[ 1 : 0 ] =00，那么转换顺序将从 ` JSQ(4-0) [4:0]` 即 ` JSQ4[4:0]` 开始。
  

### 2.6 触发源

* 配置好输入通道以及转换顺序后，就可以进行触发转换了。
* ADC 的触发转换有两种方法： 
   1. ADON 位触发转换
      * 当 ADC_CR2 寄存器的 ADON 位为 1 时，再独立给 ADON 位写 1（为防止误触发，其它位不能一起改变），此时会启动转换。
   2. 外部事件触发转换
      * 通过外部事件触发转换，例如定时器捕获、EXTI 线和软件触发，可以分为**规则组外部触发**和**注入组外部触发**。
        * **规则组外部触发**使用方法：将 EXTTRIG 位置 1，并且通过 EXTSET[2:0]位选择**规则组**启动转换的触发源。如果 EXTSET[2:0]位设置为 111，那么可以通过 SWSTART 位启动 ADC 转换，相当于软件触发。 
        * **注入组外部触发**使用方法：将 JEXTTRIG 位置 1，并且通过 JEXTSET[2:0]位选择**注入组**启动转换的触发源。如果 JEXTSET[2:0]位设置为 111，那么可以通过 JSWSTART 位启动 ADC 转换，相当于软件触发。
      * 注：ADC1 与 ADC2 的触发源相同，ADC3 的触发源和 ADC1/2 有所不同。


### 2.7 转换时间

* ADC时钟

  * ADC 的输入时钟是由 PCLK2 经过分频产生的，分频系数是由 RCC_CFGR 寄存器的 ADCPRE[1:0]位设置的，可选择 2/4/8/16 分频。
  * 需要注意的是，ADC 的输入时钟频率最大值是 14MHz，如果超过这个值将会导致 ADC 的转换结果准确度下降。 一般我们设置 PCLK2 为 72MHz。为了不超过 ADC 的最大输入时钟频率 14MHz，我们设 置 ADC 的预分频器分频系数为 6，就可以得到 ADC 的输入时钟频率为 72MHz/6，即 12MHz。 

* 转换时间

  * STM32F103 的 ADC 总转换时间的计算公式如下： 
    $$
    TCONV = 采样时间 + 12.5 个周期
    $$

  * 采样时间通过 ADC_SMPR1 和 ADC_SMPR2 寄存器中的 SMPx[2:0]位设置，x=0~17。 ADC_SMPR1 控制的是通道 0~9，ADC_SMPR2 控制的是通道 10~17。每个输入通道都支持通过编程来选择不同的采样时间，采样时间可选的范围如下： 

    ```
    SMP = 000：1.5 个 ADC 时钟周期 
    SMP = 001：7.5 个 ADC 时钟周期 
    SMP = 010：13.5 个 ADC 时钟周期 
    SMP = 011：28.5 个 ADC 时钟周期 
    SMP = 100：41.5 个 ADC 时钟周期 
    SMP = 101：55.5 个 ADC 时钟周期 
    SMP = 110：71.5 个 ADC 时钟周期 
    SMP = 111：239.5 个 ADC 时钟周期
    ```

    可以看出，最小的采样时间是 1.5 个时钟周期。若将采样时间设置为这个值，那么我们可以得到最短的转换时间。

  * ADC 的最短转换时间计算过程：
    $$
    TCONV = 1.5 个 ADC 时钟周期 + 12.5 个 ADC 时钟周期 = 14 个 ADC 时钟周期
    $$

  * 若设置PCLK2 的时钟为 72MHz，经过 ADC 时钟预分频器的 6 分频后，ADC 时钟频率 为 12MHz。代入上式可得到：
    $$
    TCONV = 14 个 ADC 时钟周期 = (
    1/12000000) ∗ 14 s = 1.17us
    $$
    

### 2.8 数据寄存器

* 根据转换组的不同，ADC 转换完成的数据将输出到不同的的数据输出寄存器。
  * 规则组的完成转换的数据输出到 ADC_DR 寄存器
  * 注入组的完成转换的数据输出到 ADC_JDRx 寄存器
  * 假如使用双重模式， 规则组的数据也是存放在 ADC_DR 寄存器。
* **ADC 规则数据寄存器（ADC_DR）：**
  * ADC 规则组数据寄存器 ADC_DR 是一个 32 位的寄存器，独立模式时只使用到该寄存器低 16 位保存 ADC1/2/3 的规则转换数据。
  * 在双 ADC 模式下，高 16 位用于保存 ADC2 转换的数据， 低 16 位用于保存 ADC1 转换的数据。 因为 ADC 的精度是 12 位的，ADC_DR 寄存器无论高 16 位还是低 16，存放数据的位宽都 是 16 位的，所以允许选择数据对齐方式。
    * 由 ADC_CR2 寄存器的 ALIGN 位设置数据对齐方式， 可选择：右对齐或左对齐。 
  * 规则组最多有 16 个输入通道，而 ADC 规则数据寄存器只有一个。如果一个规则组用到好几个通道，数据怎么读取？
    * 如果使用多通道转换，那么这些通道的数据也会存放在 DR 中。按照规则组的顺序，上一个通道转换的数据，会被下一个通道转换的数据所覆盖（所以当通道转换完成后要及时将数据取走）。
    * 比较常用的方法是**使用 DMA 模式**。当规则组的通道转换结束时，就会产生 DMA 请求，这样就可以及时把转换的数据搬运到用户指定的目的地址存放。
      * 注：只有 ADC1 和 ADC3 可以产生 DAM 请求。由 ADC2 转换的数据可以通过双 ADC 模式，利用 ADC1 的 DMA 功能传输。
* **ADC 注入数据寄存器 x（ADC_JDRx）（x=1~4）：**
  * ADC 注入数据寄存器有 4 个，注入组最多有 4 个输入通道，刚好每个通道都有自己对应的数据寄存器。
  * ADC_JDRx 寄存器是 32 位的，低 16 位有效，高 16 位保留，数据同样需要选择对齐方式。
    * 同样由 ADC_CR2 寄存器的 ALIGN 位设置数据对齐方式，可选择：右对齐或者左对齐。

### 2.9 中断

* ADC 中断可分为三种：规则组转换结束中断、注入组转换结束中断、设置了模拟看门狗状态位中断。它们都有独立的中断使能位，分别由 ADC_CR 寄存器的 EOCIE、JEOCIE、AWDIE 位设置，对应的标志位分别是 EOC、JEOC、AWD。
* **模拟看门狗中断：**
  * 发生条件：首先通过ADC_LTR和ADC_HTR寄存器设置低阈值和高阈值。开启了模拟看门狗中断后，当被 ADC 转换的模拟电压**低于低阈值**或者**高于高阈值**时，就会产生中断。
* **DMA请求：**
  * 规则组和注入组的转换结束后，除了可以产生中断外，还可以产生 DMA 请求。我们利用 DMA 及时把转换好的数据传输到指定的内存里，防止数据被覆盖。 
  * 注：只有 ADC1 和 ADC3 可以产生 DAM 请求。

### 2.10 单次转换模式和连续转换模式

* 单次转换模式
  * 通过将 ADC_CR2 寄存器的 CONT 位置 0 选择单次转换模式。该模式下，ADC 只执行一次转换，由 ADC_CR2 寄存器的 ADON 位启动（只适用于规则组），也可以通过外部触发启动 （适用于规则组或注入组）。 
  * 如果规则组的一个输入通道被转换，那么转换的数据被储存在 16 位 ADC_DR 寄存器中、 EOC（转换结束）标志位被置 1、如果设置了 EOCIE 位，则产生中断，然后 ADC 停止。` （这句话是“转换的数据被储存在 16 位 ADC_DR 寄存器中、 EOC（转换结束）标志位被置 1”以后，如果设置了eocie位则产生中断的意思吗？为什么使用顿号？什么意思？）`
  * 如果注入组的一个输入通道被转换，那么转换的数据被储存在16位ADC_DRJx寄存器中、 JEOC（转换结束）标志位被置 1、如果设置了 JEOCIE 位，则产生中断，然后 ADC 停止。
* 连续转换模式
  * 通过将 ADC_CR2 寄存器的 CONT 位置 1 选择连续转换模式。该模式下，ADC 完成上一 个通道的转换后会马上自动地启动下一个通道的转换，由 ADC_CR2 寄存器的 ADON 位启动， 也可以通过外部触发启动。 
  * 如果规则组的一个输入通道被转换，那么转换的数据被储存在 16 位 ADC_DR 寄存器中，EOC（转换结束）标志位被置 1。如果设置了 EOCIE 位，则产生中断。
    * **EOCIE：**ADC_CR1 位5
    ![image-20231103171008682](https://raw.githubusercontent.com/undefined-0/image-store/main/PicGo/202311031728090.png)
  * 如果注入组的一个输入通道被转换，那么转换的数据被储存在16位ADC_DRJx寄存器中， JEOC（转换结束）标志位被置 1。如果设置了 JEOCIE 位，则产生中断。
    * **JEOCIE：**ADC_CR1 位7![image-20231103171143177](https://raw.githubusercontent.com/undefined-0/image-store/main/PicGo/202311031728091.png)

### 2.11 扫描模式

* 可以通过 ADC_CR1 寄存器的 SCAN 位配置是否使用扫描模式。
  * 如果选择扫描模式，ADC 会扫描所有被 ADC_SQRx 寄存器或 ADC_JSQR 选中的所有通道，并对规则组或者注入组的每个通道执行单次转换，然后停止转换。但如果还设置了 CONT 位，即选择**连续转换模式**，那么转换不会在选择组的最后一个通道上停止，而是再次从选择组的第一个通道继续转换。
  * 如果设置了DMA 位，在每次 EOC 后，DMA控制器把规则组通道的转换数据传输到 SRAM 中，而注入通道转换的数据总是存储在 ADC_JDRx 寄存器中。 

## 三、单通道 ADC 采集配置步骤

1. 开启 ADCx 的时钟，然后配置 GPIO 为模拟模式。例如使用 ADC1 通道 1，对应 IO 是 PA1，它们的时钟开启方法如下： 

   ```c
   __HAL_RCC_ADC1_CLK_ENABLE(); /* 使能 ADC1 时钟 */ __HAL_RCC_GPIOA_CLK_ENABLE(); /* 开启 GPIOA 时钟 */ 
   ```

2. 通过 HAL_ADC_Init 函数来设置 ADCx 时钟分频系数、分辨率、模式、扫描方式、对齐方式等信息。

   * 注：该函数会调用：HAL_ADC_MspInit 回调函数来存放 ADC 及 GPIO 时钟使能、GPIO 初始化等代码。

3. 通过 HAL_ADC_ConfigChannel 函数来选择要配置 ADC 的通道，并设置规则序列、采样时间等。

4. 配置好 ADC 通道之后，通过 HAL_ADC_Start 函数启动 AD 转换器。

5. 调用 HAL_ADC_PollForConversion 函数等待上一次转换结束，而后通过 HAL_ADC_GetValue 来读取 ADC 值。
