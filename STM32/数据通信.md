# 数据通信：

### 1.数据通信概念：

- 在单片机的应用中，数据通信是必不可少的一部分：
  - 单片机和上位机之间的数据通信
  - 单片机和外围器件之间的数据通信
- 产生数据通信的原因：
  - 用来通信的设备之间的电气特性、传输速率、可靠性要求等各不相同，因此不同设备之间的通信要满足某种协议。
  - 我们最长用的协议有：**UART/USART**、**IIC**、**SPI**、**CAN**、**USB**等。

### 2.数据通信的方式：

#### 2.1 按照传输位数分类：

- 串行通信：
  - 数据逐位传输。
  - 优点：
    - 传输线少，布线成本低，灵活度高。
  - 缺点：
    - 传输速率低，如果传输视频肯定不行。
- 并行通信：
  - 优点：
    - 传输速率高。
  - 缺点：
    - 布线成本高，抗干扰能力差。

#### 2.2 按照传输方向分类：

- 单工：
  - 数据传输只能沿着一个方向传输，不能够实现反方向传输。
- 半双工：
  - 数据传输可以沿着两个方向，但是不能同时进行双向传输。
- 全双工：
  - 数据可以同时进行双向传输。

#### 2.3 按照同步方式分类：

- 同步通信：
  - 通信双方使用统一的时钟信号来保证传输时序。
  - 优点：
    - 可以实现高速的、大容量的数据传输。
    - 适合单点对多点的传输。
  - 缺点：
    - 收发双方要保持时钟的严格同步，硬件实现较为复杂。
- 异步通信：
  - 异步通信通过在数据中加入同步信号(例如**开始位**和**停止位**)使接收端能够将数据正确接收下来。
  - 某些通信协议中还需要双方约定传输速率。
  - 优点：
    - 硬件设计较为简单。
  - 缺点：
    - 通信速率较低，并且只适用于点对点传输。

### 3.通信速率：

#### 3.2 通信速率概念:

- 在数字通信系统中，通信速率指数据在信道中传输的速度，它分为两种：**比特率**和**波特率**。

- 比特率：

  - 每秒钟传输的**bit**数数量，单位**bit/s**。

- 波特率：

  - 每秒钟传输的码元数量，单位**Baud**。
  - 码元：
    - **码元**是信号被调制后的概念，每个**码元**都可以表示一定**bit**的数据信息量。
    - 如果码元采用**二进制编码**：
      - 比特率也是采用二进制编码，因此**波特率和比特率相等**。
    - 如果码元采用**十六进制编码**：
      - 码元有**0 ~ F**十六种，如果用二进制表示的话，每个码元需要对应**4bit**的二进制数，因此波特率是比特率的**4分之一**。

- 波特率和比特率的转换：

  - ![image-20230908215621650](C:\Users\nickaljy\AppData\Roaming\Typora\typora-user-images\image-20230908215621650.png)

  - 其中**M**表示码元的种类(对于十六进制来讲，码元有十六种)。

- 举例理解：

  - 波特率为**100Baud**，码元采用十六进制编码，这时候的比特率是**400bit/s**。

##### 在单片机的世界中，码元采用二进制编码，因此波特率等于比特率。

### 4.串口通信协议：

#### 4.1 串口通信协议简介：

- 串口通信是一种设备间常用的串行通信方式，串口按**bit**发送和接收字节。尽管按bit传输的串行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据，即实现**全双工通信**。
- **串口通信协议**是指规定了数据包的内容，内容包含了起始位、主体数据、校验位及停止位，双方需要约定一致的数据包格式才能正常收发数据的有关规范。
- 在串口通信中，常用的协议包括**RS-232**、 **RS-422**和**RS-485**等。 
- 随着科技的发展，**RS-232**在工业上还有广泛的使用，但是在商业技术上(例如电脑)，已经慢慢的使用**USB转串口**取代了**RS-232串口**。我们只需要在电路中添加一个 USB 转串口芯片，就可以实现**USB通信协议**和**标准UART串行通信协议**的转换。 

#### 4.2 串口通信协议格式：

- 参考其它文档。

#### 4.3 STM32F1的串口简介：

- **STM32F1**的串口分为两种：**USART**(即通用同步异步收发器)和**UART**(即通用异步收发器)。**UART**是在**USART**基础上裁剪掉了同步通信功能，只剩下异步通信功能。
- **STM32F1**有3个**USART**和2个**UART**，其中**USART1**的时钟源来于**APB2**时钟，其最大频率为**72MHz**，其他**4**个串口的时钟源可以来于**APB1**时钟，其最大频率为 **36MHz**。  

- **STM32**的串口输出的是**TTL**电平信号：
  - 如果需要**RS-232**标准的信号，可使用**MAX3232**芯片将**TTL**标准的信号转换为**RS-232**标准的信号。
  - 如果需要**USB**标准的信号，可使用**CH340C**芯片将**TTL**标准的信号转换为**USB**标准的信号。

#### 4.4 STM32F1的USART框图：

- ![image-20230909151604790](C:\Users\nickaljy\AppData\Roaming\Typora\typora-user-images\image-20230909151604790.png)

- 后期有时间，把框图的**每个寄存器**以及**寄存器之间的逻辑关系**以及**模块之间的关系**搞清楚。
- 波特率发生器中波特率的计算公式：
  - ![image-20230909151906743](C:\Users\nickaljy\AppData\Roaming\Typora\typora-user-images\image-20230909151906743.png)
  - 对于**USART2/3/4/5**来说，**fck**是时钟源**PCLK1**(即**APB1总线**时钟)，**USART1**的时钟源是**PCLK2**(即**APB2总线**时钟)。

#### 4.5 串口通信的配置过程：

- 直接包含以下头文件和源文件即可：

  - ```c
    #ifndef __USART_H
    #define __USART_H
    
    #include "main.h"//同时，将该头文件以及<stdio.h>头文件声明在main.h中
    
    
    /******************************************************************************************/
    /* 引脚 和 串口 定义 
     * 默认是针对USART1的.
     * 注意: 通过修改这几个宏定义,可以支持USART1~UART5任意一个串口.
     */
    #define USART_TX_GPIO_PORT                  GPIOA
    #define USART_TX_GPIO_PIN                   GPIO_PIN_9
    #define USART_TX_GPIO_CLK_ENABLE()          do{ __HAL_RCC_GPIOA_CLK_ENABLE(); }while(0)   /* PA口时钟使能 */
    
    #define USART_RX_GPIO_PORT                  GPIOA
    #define USART_RX_GPIO_PIN                   GPIO_PIN_10
    #define USART_RX_GPIO_CLK_ENABLE()          do{ __HAL_RCC_GPIOA_CLK_ENABLE(); }while(0)   /* PA口时钟使能 */
    
    #define USART_UX                            USART1
    #define USART_UX_IRQn                       USART1_IRQn
    #define USART_UX_IRQHandler                 USART1_IRQHandler
    #define USART_UX_CLK_ENABLE()               do{ __HAL_RCC_USART1_CLK_ENABLE(); }while(0)  /* USART1 时钟使能 */
    #define USART_UX_BAUDRATE					115200U
    /******************************************************************************************/
    
    #define USART_REC_LEN               200         /* 定义最大接收字节数 200 */
    #define USART_EN_RX                 1           /* 使能（1）/禁止（0）串口1接收 */
    #define RXBUFFERSIZE   1                        /* 缓存大小 */
    
    extern UART_HandleTypeDef g_uart1_handle;       /* HAL UART句柄 */
    
    extern uint8_t  g_usart_rx_buf[USART_REC_LEN];  /* 接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 */
    extern uint16_t g_usart_rx_sta;                 /* 接收状态标记 */
    extern uint8_t g_rx_buffer[RXBUFFERSIZE];       /* HAL库USART接收Buffer */
    
    
    void usart_init(void);                /* 串口初始化函数 */
    
    #endif
    ```

  - ```c
    #include "main.h"
    
    /*目前我们并没有使用操作系统，但是也添加了使用操作系统的接口*/
    /* 如果使用os,则包括下面的头文件即可. */
    #if SYS_SUPPORT_OS
    #include "os.h" /* os 使用 */
    #endif
    
    /* 加入以下代码, 支持printf函数, 而不需要选择use MicroLIB */
    
    #if 1
    /*添加AC6编译器的接口*/
    #if (__ARMCC_VERSION >= 6010050)            /* 使用AC6编译器时 */
    __asm(".global __use_no_semihosting\n\t");  /* 声明不使用半主机模式 */
    __asm(".global __ARM_use_no_argv \n\t");    /* AC6下需要声明main函数为无参数格式 */
    
    #else
    /* 使用AC5编译器时, 要在这里定义__FILE 和 不使用半主机模式 */
    #pragma import(__use_no_semihosting)
    
    struct __FILE
    {
        int handle;
        /* Whatever you require here. If the only file you are using is */
        /* standard output using printf() for debugging, no file handling */
        /* is required. */
    };
    
    #endif
    
    /* 不使用半主机模式，至少需要重定义_ttywrch\_sys_exit\_sys_command_string函数,以同时兼容AC6和AC5模式 */
    int _ttywrch(int ch)
    {
        ch = ch;
        return ch;
    }
    
    /* 定义_sys_exit()以避免使用半主机模式 */
    void _sys_exit(int x)
    {
        x = x;
    }
    
    char *_sys_command_string(char *cmd, int len)
    {
        return NULL;
    }
    
    
    /* FILE 在 stdio.h里面定义. */
    FILE __stdout;
    
    /*MDK下需要重定义fputc函数, printf函数最终会通过调用fputc输出字符串到串口*/
    int fputc(int ch, FILE *f)
    {
        while ((USART_UX->SR & 0X40) == 0);     /* 等待上一个字符发送完成 */
    
        USART_UX->DR = (uint8_t)ch;             /* 将要发送的字符 ch 写入到DR寄存器 */
        return ch;
    }
    #endif /*1*/
    /******************************************************************************************/
    
    #if USART_EN_RX /*如果使能了接收*/
    /*这个宏在usart.h中定义*/
    
    /* 接收缓冲, 最大USART_REC_LEN个字节. */
    uint8_t g_usart_rx_buf[USART_REC_LEN];
    
    /*  接收状态
     *  bit15，      接收完成标志
     *  bit14，      接收到0x0d
     *  bit13~0，    接收到的有效字节数目
    */
    uint16_t g_usart_rx_sta = 0;
    
    uint8_t g_rx_buffer[RXBUFFERSIZE];  /* HAL库使用的串口接收缓冲 */
    
    UART_HandleTypeDef g_uart1_handle;  /* UART句柄 */
    
    /**
     * @brief       串口X初始化函数
     * @param 		void
     * @note        注意: 必须设置正确的时钟源, 否则串口波特率就会设置异常.
     * @retval      void
     */
    void usart_init(void)
    {
        /*UART 初始化设置*/
        g_uart1_handle.Instance = USART_UX;                                       /* USART_UX */
        g_uart1_handle.Init.BaudRate = USART_UX_BAUDRATE;                         /* 波特率 */
        g_uart1_handle.Init.WordLength = UART_WORDLENGTH_8B;                      /* 字长为8位数据格式 */
        g_uart1_handle.Init.StopBits = UART_STOPBITS_1;                           /* 一个停止位 */
        g_uart1_handle.Init.Parity = UART_PARITY_NONE;                            /* 无奇偶校验位 */
        g_uart1_handle.Init.HwFlowCtl = UART_HWCONTROL_NONE;                      /* 无硬件流控 */
        g_uart1_handle.Init.Mode = UART_MODE_TX_RX;                               /* 收发模式 */
        HAL_UART_Init(&g_uart1_handle);                                           /* HAL_UART_Init()会使能UART1 */
    
        /* 该函数会开启接收中断：标志位UART_IT_RXNE，并且设置接收缓冲以及接收缓冲接收最大数据量 */
        HAL_UART_Receive_IT(&g_uart1_handle, (uint8_t *)g_rx_buffer, RXBUFFERSIZE); 
    }
    
    /**
     * @brief       UART底层初始化函数
     * @param       huart: UART句柄类型指针
     * @note        此函数会被HAL_UART_Init()调用
     *              完成时钟使能，引脚配置，中断配置
     * @retval      无
     */
    void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    {
        GPIO_InitTypeDef gpio_init_struct;
    
        if (huart->Instance == USART_UX)                            /* 如果是串口1，进行串口1 MSP初始化 */
        {
            USART_TX_GPIO_CLK_ENABLE();                             /* 使能串口TX脚时钟 */
            USART_RX_GPIO_CLK_ENABLE();                             /* 使能串口RX脚时钟 */
            USART_UX_CLK_ENABLE();                                  /* 使能串口时钟 */
    
            gpio_init_struct.Pin = USART_TX_GPIO_PIN;               /* 串口发送引脚号 */
            gpio_init_struct.Mode = GPIO_MODE_AF_PP;                /* 复用推挽输出 */
            gpio_init_struct.Pull = GPIO_PULLUP;                    /* 上拉 */
            gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;          /* IO速度设置为高速 */
            HAL_GPIO_Init(USART_TX_GPIO_PORT, &gpio_init_struct);
                    
            gpio_init_struct.Pin = USART_RX_GPIO_PIN;               /* 串口RX脚 模式设置 */
            gpio_init_struct.Mode = GPIO_MODE_AF_INPUT;    			/*复用输入*/
            gpio_init_struct.Pull = GPIO_PULLUP;					/*上拉*/
            gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;          /* IO速度设置为高速 */
            HAL_GPIO_Init(USART_RX_GPIO_PORT, &gpio_init_struct);   /* 串口RX脚 必须设置成输入模式 */
            
            HAL_NVIC_EnableIRQ(USART_UX_IRQn);                      /* 使能USART1中断通道 */
            HAL_NVIC_SetPriority(USART_UX_IRQn, 3, 3);              /* 组2，最低优先级:抢占优先级3，子优先级3 */
        }
    }
    
    
    /**
     * @brief       串口1中断服务函数
     * @param       无
     * @retval      无
     */
    void USART_UX_IRQHandler(void)
    {
    #if SYS_SUPPORT_OS                          /* 使用OS */
        OSIntEnter();    
    #endif
    
        HAL_UART_IRQHandler(&g_uart1_handle);   /* 调用HAL库中断处理公用函数 */
    
    #if SYS_SUPPORT_OS                          /* 使用OS */
        OSIntExit();
    #endif
    }
    
    /**
     * @brief       串口数据接收回调函数
                    数据处理在这里进行，该函数要求发送数据的最后要有回车符，否则认为数据发送失败
     * @param       huart:串口句柄
     * @retval      无
     */
    void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
    {
        if (huart->Instance == USART_UX)                    /* 如果是串口1 */
        {
            if ((g_usart_rx_sta & 0x8000) == 0)             /* 接收未完成 */
            {
                if (g_usart_rx_sta & 0x4000)                /* 接收到了0x0d（即回车键） */
                {
                    if (g_rx_buffer[0] != 0x0a)             /* 接收到的不是0x0a（即不是换行键） */
                    {
                        g_usart_rx_sta = 0;                 /* 接收错误,重新开始 */
                    }
                    else                                    /* 接收到的是0x0a（即换行键） */
                    {
                        g_usart_rx_sta |= 0x8000;           /* 接收完成了 */
                    }
                }
                else                                        /* 还没收到0X0d（即回车键） */
                {
                    if (g_rx_buffer[0] == 0x0d)
                        g_usart_rx_sta |= 0x4000;
                    else
                    {
                        g_usart_rx_buf[g_usart_rx_sta & 0X3FFF] = g_rx_buffer[0];
                        g_usart_rx_sta++;
    
                        if (g_usart_rx_sta > (USART_REC_LEN - 1))
                        {
                            g_usart_rx_sta = 0;             /* 接收数据错误,重新开始接收 */
                        }
                    }
                }
            }
    
            HAL_UART_Receive_IT(&g_uart1_handle, (uint8_t *)g_rx_buffer, RXBUFFERSIZE);/*再次开启接收中断*/
        }
    }
    #endif
    ```

  - 当前该中断的逻辑：

    - 将串口接收到的数据存入`g_usart_rx_buf`数组中，如果`g_usart_rx_sta & 0x8000 == 1`，说明接收到了数据，`g_usart_rx_sta & 0x3fff`表示接收到的数据的长度。
    - 整个中断的逻辑到上面就截止了，如果相对接收到的数据做一些操作，那么需要用户自己添加操作。

- 在**main.c**中调用`usart_init()`函数就可以完成对**USART1**的配置，接下来就能正常使用**USART1**。