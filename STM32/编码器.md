# 编码器

作者：嵌入式软件:pen:

## 1.编码器简介：

- **编码器**:tanabata_tree:：
  - 将**角位移**和**直线位移**转换成**可传输的电信号**。
    - **码盘**：将**角位移**转换成可传输电信号。
    - **码尺**：将**直线位移**转换成可传输电信号。

<img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/7af40ad162d9f2d3002cde0ba9ec8a136327cc11.jpg" alt="7af40ad162d9f2d3002cde0ba9ec8a136327cc11" style="zoom:33%;" />

- **编码器作用**:facepunch:：
  - 测量物体的**位置**、**角度**、**速度**。

## 2.编码器分类：

#### 2.1 增量编码器：

- **编码原理**:rabbit:：
  - 将**位移(角位移/直线位移)**转换成**计数脉冲**，用**脉冲个数**表示**位移大小**。
- **特点**：
  - **增量式编码器**着重计算**位移**和**速度**。
- **分类**：
  - **增量式磁电编码器**：
    - **增量式磁电编码器是我们研究的重点，后面均以增量式磁电编码器为例**。
    - **霍尔传感器**:dash:：
      - 利用**霍尔效应**
  - **增量式光电编码器**：
    - **增量式光电编码器分辨率更高，同样是我们研究的重点**。

#### 2.2 绝对编码器：

- **编码原理:radio:**：
  - **绝对编码器**的每一个位置有一个确定的**数字编码**，通过**起始/终止位置**的数字编码确定**位置/角度**。
- **特点**：
  - **绝对式编码器**着重计算**位置**和**角度**。
- **分类**：
  - **绝对式磁电编码器**
  - **绝对式光电编码器**

<img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/Gray_code_rotary_encoder_13-track_opened.jpg" alt="Gray_code_rotary_encoder_13-track_opened" style="zoom:33%;" />

## 3.编码器的参数：

#### 3.1 分辨率(PPR)：

- **分辨率**表示编码器测量的**最小距离**。
  - 对于**增量式编码器**来讲，**分辨率**表示**转轴每旋转一圈输出的脉冲个数**，用"**线**"表示:sailboat:。
    - 例如：转轴每旋转一圈，编码器输出**10**个脉冲，那么该编码器的**分辨率**是**10线**。

#### 3.2 精度：

- **精度**表示编码器**输出的信号数据**与**实际值**之间的**误差**，通常用**"角分"**、**"角秒"**表示。

#### 3.3 最大响应频率(PPS)：

- 编码器**每秒**输出的**最大脉冲数**，单位**Hz**。

#### 3.4 最大转速：

- 编码器的机械系统所能承受的**最高转速**。

## 4.增量编码器测速原理：

#### 4.1 电机相关参数：

- 在介绍增量编码器的**测速原理**之前，先理解一下和测速有关的**电机参数**：**减速比**:gear:

  - 实验室目前所用的**直流有刷电机**是**MG513**:camera:：

  - <img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/img_v2_45c66c74-6da9-4951-88a1-a2a15f4fa43g.jpg" alt="img_v2_45c66c74-6da9-4951-88a1-a2a15f4fa43g" style="zoom:50%;" />
  - **直流有刷电机**为了避免电机转轴旋转速度过快，通常会搭配**减速箱**，因此我们要知道电机的**减速比**。
  - <img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/img_v2_e6975351-2fb5-4f06-a14c-0d3b43340ddg.jpg" alt="img_v2_e6975351-2fb5-4f06-a14c-0d3b43340ddg" style="zoom: 67%;" />
    - **1:30减速比**：
      - 电机的**转轴**每旋转一圈，电机的**转子**旋转30圈。

- **注意，编码器的转轴连接到电机的转子上面**。

#### 4.2 编码器相关参数：

- **分辨率**:waning_gibbous_moon:：
  - **霍尔编码器**的**稳定性高**，因此直接**裸露**在电机外侧，不需要外壳保护。
  - <img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/img_v2_f9d4448b-40c9-4942-9dbc-5f93f9b5092g.jpg" alt="img_v2_f9d4448b-40c9-4942-9dbc-5f93f9b5092g" style="zoom:50%;" />
  - 该款电机搭配**13PPR**霍尔编码器。
    - 霍尔编码器每旋转一圈，产生**13个计数脉冲**。
- **供电范围**:expressionless:：
  - 该款电机的霍尔编码器供电范围：**3.3 ~ 5v**

#### 4.3 测速原理：

- 这里以**旋转型增量编码器**(可测量**角位移**)为例，编码器在旋转过程中有**两相**(当然也有三相输出的:volcano:)输出，分别称为**A相**和**B相**，**A相**和**B相**的**计数脉冲**数量相同，但两相输出是**正交输出**(相位相差90°)。
- **测速**：
  - 对**A相/B相**的脉冲进行计数，可以得到$dt$时间内编码器的**脉冲总数**$Sum_{epulse}$
  - 已知编码器**分辨率**：**13PPR**，因此$dt$时间内编码器的**旋转圈数**$Sum_{ecircle} = Sum_{epulse} / 13$
  - 已知电机的**减速比**是**1:30**，因此$dt$时间内电机的**旋转圈数**$Sum_{mcircle} = Sum_{ecircle} / 30$
  - 最终求出**1min**内电机的旋转圈数，即可得到电机的转速**RPM**。
- **测旋转方向**：
  - **我们以计数脉冲的上升沿为参照点**。
  - 由于**A/B两相正交**，因此存在两种情况：
    - **A相上升沿在B相前面**:3rd_place_medal:：
      - 此时编码器**顺时针**旋转，认为电机**正转**。
    - **B相上升沿在A相前面**:2nd_place_medal:：
      - 此时编码器**逆时针**旋转，认为电机**反转**。

<img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/1920px-Quadrature_Diagram.svg.png" alt="1920px-Quadrature_Diagram.svg" style="zoom: 33%;" />

## 5.STM32的编码器驱动代码：

#### 5.1 定时器编码器模式：

- **STM32**的**通用定时器**和**高级定时器**都有该模式，用来对编码器的**计数脉冲**进行计数。
  - 可以认为是**输入捕获**的一个子模式。
- 通用定时器的**通道1**和**通道2**连接编码器的**A相**和**B相**，经过**输入滤波器**和**边沿检测器**，输出**TI1FP1**和**TI2FP2**两路信号，这两路信号进入**编码器接口**，编码器输出一路脉冲信号，随后经过**预分频寄存器(TIMx_PSC)**的分频，作为**计数器**的时钟信号。
  - 计数器负责对**计数脉冲**进行**计数**。

<img src="https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/image-20231005132110959.png" alt="image-20231005132110959" style="zoom:67%;" />

- **定时器识别编码器的方向**：
  - ![image-20231005133306981](C:\Users\nickaljy\AppData\Roaming\Typora\typora-user-images\image-20231005133306981.png)
  - 假设编码器接口输出信号是**TI1**(也就是**TI1FP1**)，此时相当于仅在**TI1**计数：
    - 当**TI1FP1**处于**上升沿**的时候，若**TI2**是**高电平**，则定时器处于**向下计数**模式。
      - 此时可以认为编码器的**A相**上升沿在**B相**上升沿**之后**，即编码器**逆时针**旋转，电机**反转**。
    - 当**TI1FP1**处于**上升沿**的时候，若**TI2**是**低电平**，则定时器处于**向上计数**模式。
      - 此时可以认为编码器的**A相**上升沿在**B相**上升沿**之前**，即编码器**顺时针**旋转，电机**正转**。
  - 上述只分析了**上升沿计数**的情况，根据图片可知，对于编码器接口的输出信号，定时器对**上升沿**和**下降沿**均产生**计数**：
    - 对于**编码器**来讲，一个脉冲周期被定时器计数两次，**13PPR**的编码器在旋转一圈之后，定时器实际计数值为**13 x 2 = 26**。
    - 因此采用**"仅在TI1计数"/"仅在TI2计数"**时，相当于把编码器的**分辨率x2**。
  - 采用**"在TI1和TI2上计数"**时，在四个边沿计数，相当于把编码器的**分辨率x4**，通常选择这种方式计数。
  - **获取计数器计数方向**：
    - **计数器的计数方向，对应电机的旋转方向**。
    - ![image-20231005140851968](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/image-20231005140851968.png)
    - 该寄存器的**DIR位**表示计数器的计数方向，在**编码器模式**下，该位为**只读**：
      - **0：计数器向上计数** 
      - **1：计数器向下计数**

#### 5.2 编码器驱动代码：

- **第一步：创建定时器句柄**

  - ```c
    *****************************/*调用编码器初始化函数*/*********************************
    TIM_HandleTypeDef general_time_handle;
    general_time_handle.Instance = TIM4;
    general_time_handle.Init.Prescaler = psc;
    general_time_handle.Init.Period = arr;
    general_time_handle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    ```

  - `general_time_handle.Init.Prescaler`：

    - 此时外部脉冲信号**TIx经过一系列变化**，作为定时器的**输入时钟**，这个参数用于对定时器的**输入时钟进行分频**。

  - `general_time_handle.Init.Period`：

    - 该参数用来配置计数器的**最大计数值**。

  - `general_time_handle.Init.ClockDivision`：

    - 该参数用来配置$f_{DTS}$，$f_{DTS}$决定了输入滤波器的频率：
      - `TIM_CLOCKDIVISION_DIV1`，$f_{DTS} = f_{CKINT}$。
      - `TIM_CLOCKDIVISION_DIV2`，$f_{DTS} = f_{CKINT} / 2$。
      - `TIM_CLOCKDIVISION_DIV4`，$f_{DTS} = f_{CKINT} / 4$。

  - 不需要设置**计数模式**，因为定时器会根据编码器的**A/B相**自动匹配计数模式。

- **第二步：创建编码器结构体**

  - ```c
    ***************************************************/*编码器结构体*/********************************************************
    typedef struct
    {
      uint32_t EncoderMode;  /* 编码器接口的计数模式 */
      uint32_t IC1Polarity;  /* 定时器通道1的极性 */  
      uint32_t IC1Selection; /* 输入通道对应关系选择 */         
      uint32_t IC1Prescaler; /* 输出信号分频系数 */                      
      uint32_t IC1Filter;    /* 滤波器参数设置 */                           
      uint32_t IC2Polarity;  /* 定时器通道2的极性 */                           
      uint32_t IC2Selection; /* 输入通道对应关系选择 */                           
      uint32_t IC2Prescaler; /* 输出信号分频系数 */                              
      uint32_t IC2Filter;    /* 滤波器参数设置 */                             
    } TIM_Encoder_InitTypeDef;
    TIM_Encoder_InitTypeDef encoder_tim_init_struct;  /* 编码器初始化结构体 */
    ```

  - **说实在的，这个结构体里面的参数真的抽象，但是要把这些参数理解了，定时器框图的一大部分也都理解了**:hot_pepper:。

    - 首先来看`EncoderMode`：
      - 这个不难理解，也就是告诉定时器中的计数器到底该**如何计数**，这个参数决定了输入到**CK_PSC**的脉冲信号。
      - `TIM_ENCODERMODE_TI1`：
        - 只对**TI1FP1**的脉冲信号的**边沿**(上升沿、下降沿**都计数**)进行计数，此时相当于把编码器的**分辨率x2**。
      - `TIM_ENCODERMODE_TI2`：
        - 只对**TI2FP2**的脉冲信号的边沿进行**计数**，此时相当于把编码器的**分辨率x2**。
      - `IM_ENCODERMODE_TI12`：
        - 对**TI1FP1**和**TI2FP2**两路脉冲信号的边沿进行**计数**，相当于把编码器的**分辨率x4**。
    - `IC1Polarity`：
      - **IC1的极性**，这个参数就比较抽象了，想要理解这个参数，就需要了解**输入滤波器**和**边沿检测器**。
      - **STM32**的通用定时器和高级定时器支持**输入捕获**，对于**捕获/比较寄存器**来讲，捕获的信号是**ICxPS**(**见上面的定时器结构框图**)，**ICxPS**是由**TIx**经过一系列操作得到的信号，接下来我们就说清楚这个转换过程。
      - ![image-20231005164909421](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/image-20231005164909421.png)
      - **输入滤波器(Input Filter)**：
        - **滤波器存在的目的**：
          - **防止因输入信号的噪声或边沿抖动导致误计数、误触发**。
        - **TIx**将首先进入**输入滤波器**，输入滤波器通过**TIMx_CCMR1.ICF**域进行配置：
          - **ICF域**用来控制**采样(sampling)频率**和**滤波器长度(N)**，。 
          - ![image-20231005163827966](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/image-20231005163827966.png)
          - $f_{DTS}$请参考相关配置寄存器，我们可以简单理解成$f_{CKINT}$。
            - 几乎不用考虑滤波器的$f_{SAMPLING}$小于$f_{TIx}$，因此可以认为滤波器不会改变输入信号的频率。
          - 我们假设**ICF域**的值是**1010**：$f_{SAMPLING} = f_{DTS}/16, N = 5$
            - ![image-20231005181227003](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/image-20231005181227003.png)
            - 滤波器会在**上升沿采样**(过滤毛刺等......:ear_of_rice:)，上图滤波器长度是**5**(即采样周期为5)，如果输入脉冲的**高电平宽度**不能维持**完整的采样周期**的长度，则认为是**高频杂波**，于是过滤掉(变为低电平)，如果维持**完整的采样周期**，则**滤波器**会在**最后一个采样周期**的时候输出**上升沿跳变**，即将输入脉冲**无影响输出**。
        - **TIx**经过滤波器之后变为**TIxF**，**TIxF**进入**边沿检测器**。
      - **边沿检测器(Edge Detector)**：
        - **边沿检测的作用**：
          - 对输入信号**TIxF**做**反相变换**。
          - **反相的目的**：
            - **捕获/比较寄存器**只能捕获脉冲信号的**上升沿**(硬件决定)，但有时我们希望捕获脉冲信号的**下降沿**。
            - 如果我们想捕获脉冲信号的**下降沿**，那么完全可以把**脉冲信号旋转180°**，即**反相变换**，这样脉冲信号的**原下降沿**就变成的**新上升沿**，捕获/比较寄存器就能够捕获。
        - **TIx**经过边沿检测器之后会输出**两路**脉冲信号：
          - **TIxF_Rising**，捕获原始脉冲信号的上升沿，因此原始脉冲信号不需要反相。
          - **TIxF_Falling**，捕获原始脉冲信号的下降沿，因此原始脉冲信号需要反相。
        - 通过配置**TIMx_CCER.CCxP**域来配置**捕获极性**：
          - **TIMx_CCER.CCxP = 0**，捕获原始脉冲信号的**上升沿**，原始脉冲信号**不反相**。
          - **TIMx_CCER.CCxP = 1**，捕获原始脉冲信号的**下降沿**，原始脉冲信号**反相**。
        - **TIxF**经过边沿检测器之后变为**TIxFPx**。
      - 在定时器结构框图中，**TI1**经过输入滤波器和边沿检测器之后产生了**TI1FP1**和**TI1FP2**两路信号：
        - **TI1FP1**和**TI1FP2**两路脉冲信号完全相同，都是**TI1**经过滤波了边沿检测得到，产生这两路信号的原因是**通道/捕获映射**。
        - 通常来讲，有**三种**映射关系，这个映射关系通过**TIMx_CCRM.CCxS域**设置(分别介绍**通道1/2**和**通道3/4**)：
          - **通道1/2**(以**CC2S**域为例)：
            - 01：IC2映射在TI2上(**IC2—TI2FP2**)。
            - 10：IC2映射在TI1上(**IC2—TI1FP2**)。
            - 11：IC2映射在TRC上。
          - **通道3/4**(以**CC3S**域为例)：
            - 01：IC3映射在TI3上(**IC3—TI3FP3**)。
            - 10：IC3映射在TI4上(**IC3—TI4FP3**)。
            - 11：IC3映射在TRC上。
      - 峰回路转，我们接着说`IC1Polarity`：
        - 实际上，这个参数用来决定**TI1FP1**是采用经过**边沿检测器**反相过的信号还是没反相过的信号。
        - `TIM_ENCODERINPUTPOLARITY_RISING`，表示采用没反相过的信号。
        - `TIM_ENCODERINPUTPOLARITY_FALLING`，表示采用反相过的信号。
    - `IC1Selection`：
      - 这个参数用来选择**通道1**的**通道/捕获映射**关系。
      - `TIM_ICSELECTION_DIRECTTI`，表示**IC1—TI1FP1**。
      - `TIM_ICSELECTION_INDIRECTTI`，表示**IC1—TI2FP1**。
      - `TIM_ICSELECTION_TRC`，表示**IC1—TRC**。
    - `IC1Prescaler`：
      - 这个参数用来对**IC1**的脉冲信号进行**分频**。
      - `TIM_ICPSC_DIV1`，不对**IC1**进行分频。
      - `TIM_ICPSC_DIV2`，二分频。
        - **捕获/比较寄存器**会在**上升沿**进行捕获，二分频表示每两个**上升沿**捕获一次。
      - `TIM_ICPSC_DIV4`，四分频。
      - `TIM_ICPSC_DIV8`，八分频。
    - `IC1Filter`：
      - 对**通道1**的**滤波器**进行配置。
      - **IC1Filter**的取值和**TIMx_CCMR1.ICF**相同。

- **第三步：初始化编码器接口**

  - ```c
    *****************************/*调用编码器初始化函数*/*********************************
    HAL_TIM_Encoder_Init(&general_time_handle, &encoder_tim_init_struct);
    ```

- **第四步：重写编码器接口底层驱动函数**

  - `void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim);`是`HAL_TIM_Encoder_Init`的**回调函数**，会在最后执行调用。

    - 需要对定时器**通道1/2**相对应的**GPIO**进行初始化，以及设置**更新中断**的**中断优先级**。
      - **通道1—GPIOB6**
      - **通道2—GPIOB7**

  - ```c
    void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
    {
        if (htim->Instance == TIM4)
        {
            GPIO_InitTypeDef gpio_init_struct;//创建GPIO初始化结构体
            __HAL_RCC_GPIOB_CLK_ENABLE();//开启GPIOC时钟
    		__HAL_RCC_TIM1_CLK_ENABLE();//开启TIM1时钟
    
            gpio_init_struct.Pin = GPIO_PIN_6;                
            gpio_init_struct.Mode = GPIO_MODE_AF_PP;//复用推挽输出
            gpio_init_struct.Pull = GPIO_NOPULL;//作为编码器的输入相，不需要上拉或下拉 
            gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;      
            HAL_GPIO_Init(GPIOC, &gpio_init_struct);//初始化  
            
            gpio_init_struct.Pin = GPIO_PIN_7;                   
            gpio_init_struct.Mode = GPIO_MODE_AF_PP;                                  
            gpio_init_struct.Pull = GPIO_NOPULL;                                    
            gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;                             
            HAL_GPIO_Init(GPIOC, &gpio_init_struct);         
          
            HAL_NVIC_SetPriority(TIM4_IRQn, 2, 0);//配置更新中断的优先级                   
            HAL_NVIC_EnableIRQ(TIM4_IRQn);//将更新中断的入口在NVIC处使能                   
        }
    }
    ```
    
  - 重点：为什么要将GPIO设置成**复用推挽输出**，而不是**输入模式**？

    - 这里重要的不是**输出**和**输入**，而是**复用**。
    - 在编码器模式下，定时器的两个通道是作为**输入通道**，因此相应的**GPIO引脚**也作为**输入引脚**，但不是作为**GPIO**使用，而是作为**输入通道**来使用。
      - 因此要将**GPIO**复用成**定时器通道**，定时器通道具体执行的是输出还是输入由**定时器的模式**决定。

- **第四步：开启通道编码器接口**

  - `encoder_tim_init_struct`这个结构体对两个通道的参数进行了配置，因此要**分别开启两个通道**。

  - ```c
    HAL_TIM_Encoder_Start(&encoder_tim_init_struct, TIM_CHANNEL_1);
    HAL_TIM_Encoder_Start(&encoder_tim_init_struct, TIM_CHANNEL_2);
    ```

- **第五步：使能定时器的更新中断**

  - ```c
    __HAL_TIM_CLEAR_FLAG(&general_time_handle,TIM_IT_UPDATE);
    //避免上一次的更新中断标志位没有清除，先清除更新中断标志位
    __HAL_TIM_ENABLE_IT(&general_time_handle,TIM_IT_UPDATE);
    //使能定时器更新中断
    ```

  - 当定时器**计数溢出**的时候，就会设置定时器的**更新中断标志位**。

- **第六步：重写更新中断的中断服务函数**

  - 对于**定时器4**来讲，该**入口函数**是`void TIM4_IRQHandler(void)`：

    - ```c
      void TIM4_IRQHandler(void)
      {
          HAL_TIM_IRQHandler(&general_time_handle);
      }
      ```

    - `void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)`是**公共中断服务函数**。

- **第七步：重写更新中断的中断回调函数**

  - ```c
    void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
    {  
         if (htim->Instance == TIM4)
         {
            if(__HAL_TIM_IS_TIM_COUNTING_DOWN(&general_time_handle))                           /* 判断CR1的DIR位，即判断定时器是否是向下计数 */
            {
                encoder_tim_count--;                                                           /* DIR位为1，也就是递减计数 */
            }
            else
            {
                encoder_tim_count++;                                                           /* DIR位为0，也就是递增计数 */
            }
         }
    }
    ```

  - 要想知道`encoder_tim_count--`和`encoder_tim_count++`的作用，需要了解编码器的**计数公式**：

    - ```c
      int encoder_tim_get_encode(void)
      {
          return (int32_t)__HAL_TIM_GET_COUNTER(&general_time_handle) + encoder_tim_count * 65536;   /* 总的编码器值 = 当前计数值 + 之前累计编码器的值 */
      }
      ```

    - **65536表定时器的TIMx_ARR设置为65535，即定时器连续计数次数是65535次**。

    - 编码器值有**正负**，当编码器正转的时候，计数值为正，编码器反转的时候，计数值为负。

- **第八步：使用基本定时器定时**

  - 用来计算两次读取编码器值的时间差，得到编码器的转速，进而得到电机的转速。

